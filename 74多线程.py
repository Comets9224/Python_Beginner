#360卫士下的 多个线程，进程来完成任务，消耗就大
#线程的任务都要在进程下工作，线程属于进程的一部分，不需要额外的空间
#线程要一直下载着，要持续占用内存，就用线程来做
#可以拿更小的单元运行任务,为什么还要拿进程?
#线程不接触系统CPU资源,共享进程的资源,只占用系统的一点资源,可以创建可以撤销线程,线程之间能相互制约,是并发执行的(轮流着运行,就是CPU运行切换到快),
#线程也有三种状态，也有阻塞，非阻塞，
"""
线程（Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程中，是进程中的实际运作单位。
一个进程可以由多个线程组成，这些线程共享该进程的资源，如内存空间、文件描述符等。

线程，有时被称为轻量进程（Lightweight Process，LWP），是程序执行流的最小单位。一个标准的线程由线程ID、当前指令指针（PC）
、寄存器集合和堆栈组成。 另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位。线程自己不拥有系统资源，只拥有一点
在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中
的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中出现相应的中断性。线程在运行时，阻塞和运行三种基本状态。
就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待
一个事件（如某个信号量），逻辑上不可以执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。

线程是程序中一个单一的顺序控制流程。进程内有一个相对独立、可调度的执行单元，是系统独立调度和分派CPU的基本单位指程序内运行的程序的调度单位。
若一个程序同时运行多个线程完成不同的工作，称为多线程。

优点：
使用线程可以把占据长时间的程序中的任务放到后台去处理。
用户界面可以更加强引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。
程序的运行速度可能加快。
在一些等待的任务实现上，如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放心一些珍贵的资源如内存占用等。
Python通过两个标准库thread和threading提供对线程的支持。thread提供了低级别的、原始的线程以及一个简单的锁。

threading模块提供的其他方法：

threading.currentThread()：返回当前的线程变量。
threading.enumerate()：返回一个包含正在运行的线程的列表。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
threading.activeCount()：返回正在运行的线程数量。与len(threading.enumerate())有相同的结果。
"""

"""
threading模块处理线程
考虑?创建线程?如何使用线程?
使用:  t1=threading.Thread(target=download,name='aa',args=(1,))#download 后面不要加括号,创建了一个线程对象
       t1.start()
线程的状态:新建,就绪,运行,阻塞,结束(阻塞完了还要跑到就绪上面)



进程 ----Process类
线程------Thread类
"""
import threading
from time import sleep
# def download(n):
#     images=['girl.jpg','girl.jpg','boy.jpg','man.jpg']
#     for image in images:
#         print('正在下载',image)
#         sleep(1)
#         print('下载成功!')
# def listenMusic():
#     music_list=['大碗宽面','土耳其冰淇淋','烤馒头片']
#     for music in music_list:
#         sleep(1)
#         print('正在听',music)
# if __name__ == '__main__':
#     t1=threading.Thread(target=download,name='aa',args=(1,))#download 后面不要加括号,创建了一个线程对象
#     t1.start()
#     t2=threading.Thread(target=listenMusic,name='aa')
#     t2.start()
#     n=1
#     while True:
#         print(n)
#         sleep(1.5)
#         n=n+1
#发现主进程在不断的运行1,2,3  但是,子线程运行完就不结束了
#且,正在下载1的过程中  主进程继续打印 2, 3 4   线程没执行完不影响主进程

#线程的状态经历_
"""
1.新建状态,---->start---->2.就绪状态---->
---->3.运行状态(没人抢就不会并发)---->4.a运行完就结束
  或----->4.b  运行过程中sleep 就会阻塞,睡醒又跑到2的就绪状态,而不是去4.a 运行完结束
  
  举例 线程1  线程2 不会同时进CPU资源，而是只有一个进CPU，如果线程1睡着了，线程2/3进，
  睡醒了也不能立刻回来，要回到就绪状态等着
  到底是线程2还是3进 这由CPU决定，我们是不确定的。
"""

"""前面的学习得知,
多个进程如果共享一个公共的数据,
这个数据会在两个进程里都各自拿
一个空间进行存储

那线程呢?也共享吗?会有什么问题呢
"""
# money=1000
#
# def func1():
#     global money
#     for i in range(10):
#         sleep(1)
#         money-=1
#         print('func1:', money)
# def func2():
#     global money
#     for i in range(10):
#         sleep(1.1)   #两个时间错开避免允许撞一起
#         money-=1
#         print('func2:',money)
#
# if __name__ == '__main__':
#     t1=threading.Thread(target=func1,name='th1')
#     t2=threading.Thread(target=func2,name='th2')
#     t1.start()
#     t2.start()
#
#     t1.join()   #阻塞 插队在主进程里
#     t2.join()
#
#     print('money:',money)
#     #结果为800,说明每个进程都减1
"""
所以线程是允许共享全局的,可以做卖票卖票,加速包,就是底层线程多开一些


"""

n=0
def task1():
    global n
    for i in range(500000):
        n+=1
        #print('---->task1中n的值是0:',n)


def task2():
    global n
    for i in range(500000):
        n += 1
        #print('---->task2中n的值是0:', n)
if __name__ == '__main__':
    th1 = threading.Thread(target=task1)
    th2 = threading.Thread(target=task2)  #不起名也没关系 name=''
    th1.start()
    th2.start()

    print('最后打印的n是---->',n)  #发现最后不是二百万
"""    数小的时候,线程同步
    线程同步,默认加了锁,叫GIL锁，全局解释器锁
    python说是多线程,线程状态做的不是很好,数大就没这个锁了,数小就有这个锁.
    多大的数是大？

    线程1拿到执行权  取n-=1  也就是 n-1  --->n=n赋值两步
    中间任意一步都可能被别的线程抢占了资源  可能只是做了n-1  但值没有赋值  减了也白减
    这时候线程2取了n做n-=1    轮着做 就会出现数据不安全(数据不安全指数据不是我想要的)很容易出现重复的票
    线程是  从哪停从哪开始,比如已经执行了  n-1  那下次进来就是n=n赋值
    解决方法:线程同步,加线程锁,线程1没干完 后面的不许进,速度慢,不共享数据还行,共享数据就要慢,加锁加lock,防止数据出错
    等线程1出来后,其他进
    Python底层:只要用线程,底层默认加锁,也就是解释器锁
    只要有锁,就没法达到想要的速度,也就没法真正达成多线程
    python诞生之初就有这个锁,太底层了
    
    那为什么大数情况下锁又解了呢?:只要达到一定释放量,自动会解开锁,那到底多大算大呢?
    
    所以特点:
    线程:计算量不大情况,会有锁的风险,耗时操作时候,就用线程做  耗时操作  IO   爬虫
    进程:计算密集型,用进程,运算量大的就合适,单独分配资源
    GIL单核双核使用的问题也涉及到进程线程的选用
    
    不是共享数据,没必要加锁,但也加了锁
    
    可以手动加锁:lock方法  acquare请求锁
"""