"""正则表达式"""
"""
正则表达式（Regular Expression，简称regex或regexp）是一种用于匹配字符串中字符模式的强大工具。它在文本处理、
数据验证、字符串搜索和替换等场景中非常有用。正则表达式通过特定的语法规则定义字符模式，可以实现复杂的文本匹配和操作。
"""
"""
引入例子：
#验证qq登录
#1.验证长度
#2.验证是否0开头
qq=input('请输入qq号码:')
if len(qq)>=5 and qq[0]!='0':
    print('合法的')
else:
    print('不合法的')
"""
# 正则用于字符串的匹配，匹配特殊字符串和普通字符串，组成特定格式的字符串，这个字符串就是过滤条件
# 是文本模式，拿正则和字符串去比较 ，验证字符串是否符合我的要求
# 1.匹配 或  2.通过筛选得到我要的字符串

"""
正则表达式的作用和特点 给定一个正则表达式和另一个字符串，我们可以达到如下的目的：
给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）；
可以通过正则表达式，从字符串中获取我们想要的特定部分。
正则表达式的特点是：

灵活性、逻辑性和功能性非常强；
可以迅速地用极简单的方式达到字符串的复杂控制；
对于刚接触的人来说，比较晦涩难懂。
场景：
如何判断一个字符串是否是手机号呢？
判断邮箱为163或者126的所有邮件地址。
"""
import re

msg = '娜扎热巴戴斯佟丽娅'
pattern = re.compile('佟丽娅')  # 编译一个 正则的格式  返回匹配对象  给你个正则，下面去匹配
pattern.match(msg)
print(pattern.match(msg))  # 没有匹配成功返回None，然后就退出匹配了   佟丽娅往开头放 就能匹配到了，也就是只匹配 头

# 进入真正正则，不用‘佟丽娅’  底层都处理好了
# 使用正则re模块方法 ：math
s = '娜扎佟丽娅热巴代斯'
result = re.match('佟丽娅', s)  # 一个佟丽娅 一个字符串
print(result)  # math底层封装了上文partern

result = re.search('佟丽娅', s)  # search 会匹配整个字符串  没有返回None
print(result)
print(result.span())  # 如何是None 返回span，会报错，返回位置

print(result.span(0))  # 0 表示匹配对象的第0组，即整个匹配。如果匹配对象中有捕获组（用圆括号()包围的子表达式），可以使用 span(n) 获取第 n 组的起始和结束位置
# 返回内容
print(result)
print(result.group())  # group 提取到匹配到的内容
# 不加group返回的是？re.Match的匹配对象  还不算你要的内容
print(result.groups())  # 返回空元组
print('------------------------')
# a2b h6k
s = '哈哈6'
result = re.search('[0-9]', s)
print(result.group())
print('-----------------------')
s = '哈哈6v'
result = re.search('[0-9][a-z]', s)  # 不符合会返回None
# [] 表示是一个范围0-9 和0123456789是一样的 [1-9][a-z]挨着,搜索时候必须两个条件都满足
# print(result.group())#小心返回错误  None值是取不出的
print(result)
print('-----------------------')
msg = 'abcd7v jkfd8hdf00'
result = re.search('[a-z][0-9][a-z]', msg)  # 引号内放 正则表达式：筛子
# search 偷懒,只要找到一个就不往下找了  可找其他方法
print(result.group())
print('-----------------------')
result = re.findall('[a-z][0-9][a-z]', msg)  # 返回值是一个列表  findall会一直找,直到结尾

print(result)
print('-----------------------')
# 现在 a7a a88a a7878a  怎么取
"""
定义正则验证次数
*: 匹配前面的子表达式零次或多次(贪婪模式,经可能多的匹配)   表次数>=0  没有也行 有最好
+: 匹配前面的子表达式一次或多次  次数>=1
?: 匹配前面的子表达式零次或一次   0次或1次
"""
msg = 'a7a0pa88akijka7878a'
result = re.findall('[a-z][0-9]+[a-z]', msg)  # 加号在谁后面,表示谁的次数
print(result)
print('-----------------------')
# qq号码验证
# qq='01234658470'
qq = '149446'  # ^是放到正则式里的  如果函数方法用的match ^其实无所谓  表示,拿整个正则式,和开头结尾去匹配
# 拿149446整体  放到正则去比较  149446 ,正则里是四位  qq是五位  返回None  ,$表示字符串取完
result = re.match('^[1-9][0-9]{5,10}$', qq)  # 加{4}的情况  能匹配 但是是拿部分去匹配 不是整行qq去匹配  这时候拿行首行尾去匹配
# 5表示 规定好了,只能是五位,四位不行六位也不行  上面的5  是不包含第一位之外的  要五位,qq总共六位   如果我qq是5,6,7,8,9位都可以呢?{m,} 加逗号
"""
{m}表只能匹配m次,{m,}表示>=m次  ,那限制多少次,{m,n} 表 限制最多n次    大于等于m次 小于等于n次
^: 匹配字符串的开头
$: 匹配字符串的结尾
"""
if result == None:
    print('QQ号码不符合规则')  # 号码长度5-11位  要验证  '{m}' 用于验证前面的模式匹配必须是m次

else:
    print(result.group())
print('-----------------------')
#用户名可以是字母和数字,不能数字开头,用户名长度必须6位以上
username='admin001'  #要拿整个字符串和正则匹配,那么,加上^和$
# 如果单一个^  那就是只要求[a-zA-Z] 开头,单一个$  那就是以[0-9a-zA-Z]{5,}] 结尾  两个组合在一起 才是以^开头以$结尾
result=re.search('^[a-zA-Z]\w{5,}$',username)    #\w 就是字母数字下划线(包括大小写)
print(result)
"""
search和math区别:
re.match：从字符串的开头开始匹配，如果开头部分不匹配则返回 None。 match
可以省略^  因为match就默认是从头开始匹配
re.search：在整个字符串中搜索第一个匹配项，可以匹配字符串的任何部分。
re.findall:遍历所有的,找出所有匹配项.
"""
print('-------------------')
msg='aa.py ab.txt bb.py kk.png uu.py openxpyl'  #openxpyl可以用\B匹配
result=re.findall(r'\w*.py\b',msg)   #转义字符里有\b  所以要多加一条斜杠,或者前面加r ,出现斜杠都要防止转义的情况
#点在正则中,有别的意思,点能匹配点  ,点在正则中,叫任意字符,但是我们这里 只是想匹配'.'  所以要用转义的意思,而不是正则任意字符的点
print(result)
#[] 范围  [abc]   [a-z]  [a-z*&￥]
"""
\b表示,匹配一个单词边界  配openpyxl中的py,但不能匹配pyhon中的py
单词和空格间的位置 ,py\b可以匹配到python中的py,但不能匹配openpyxl中的py
"""
print('--------------------')
"""正则预定义  想用正则表达式的意思,往往要转义
\s  空白  (空格)
\b  边界
\d  数字
\w word [0-9a-zA-Z]
大写反面  \S 表非空格  \D 表非数字
'\w[0-9]'  ----->\w仅仅表示一个字母的匹配  [0-9]也只匹配一个字母
这时候要用一些量词
*  >=0
+  >=1
?  0,1

#比如手机号码必须十一位
re.match('1'[35789]\d{9}$,phone)  #如果范围固定 直接写1就ok  


"""
#正则符号

"""
字符    当^出现在括号内[],表示取反,  小写的表示是正的 ok的,大写就是相反的 ,不ok的.
.: 匹配除换行符以外的任意单个字符。
相当于：[^\n]（在某些实现中，可能需要使用 DOTALL 模式来匹配换行符）

\d: 匹配任何数字字符。
相当于：[0-9]

\D: 匹配任何非数字字符。
相当于：[^0-9]   相当于[^\d]

\w: 匹配任何字母数字字符（包括下划线）。   
相当于：[a-zA-Z0-9_]

\W: 匹配任何非字母数字字符。
相当于：[^a-zA-Z0-9_]

\s: 匹配任何空白字符（空格、制表符、换页符等）。   space
相当于：[ \t\n\r\f\v]（空格、制表符、换行符、回车符、换页符、垂直制表符）

\S: 匹配任何非空白字符。   not space
相当于：[^ \t\n\r\f\v]
边界


\b: 匹配一个单词边界
\B: 匹配非单词边界
量词

*: 匹配前面的子表达式零次或多次
+: 匹配前面的子表达式一次或多次
?: 匹配前面的子表达式零次或一次
{n}: 恰好匹配 n 次
{n,}: 匹配至少 n 次
{n,m}: 匹配至少 n 次且不超过 m 次
分组和选择

(): 定义一个子表达式（用于分组）
|: 选择，匹配 | 前或后的子表达式
字符类

[]: 定义一个字符类，匹配方括号内的任意字符
[^]: 定义一个否定字符类，匹配不在方括号内的任意字符
转义

\: 用于转义特殊字符，使其失去特殊含义
其他

(?i): 忽略大小写匹配
(?:...): 非捕获组，只做匹配不捕获结果
"""
