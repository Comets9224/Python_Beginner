#单核多任务的原理:操作系统,轮流任务交替,表面上是每个任务同时进行
#实际上cpu是在各个任务之间切换 ,每个程序运行2us
#真正要运行,还得多核CPU上实现多任务  由于任务数量远多于CPU核心，所以操作也是把任务轮流分配到每个核心上执行
#这涉及了并发 并行
"""什么是并发并行"""
"""
并发（Concurrency）
并发是指在同一时间段内处理多个任务。  ----单核
并发系统能够在某一时刻暂停一个任务并开始或继续另一个任务，
从而使多个任务“同时”进行。并发并不要求这些任务实际在同一时刻执行，而是通过任务切换来实现“同时”进行的效果。
 其中一个线程运行,其他就处于挂起状态,这称为并发
 
并行（Parallelism）  ----多核
并行是指在同一时刻真正地同时执行多个任务。并行处理需要有多个处理器或多核处理器，
每个处理器或核心同时执行不同的任务，从而实现真正的同时执行。

实现多任务的方式：
多进程模式:
多线程模式:
协程:
进程 > 线程 > 协程

一、 多进程
进程（Process） 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当前面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。

对于操作系统来说，一个任务就是一个进程。例如，启动一个浏览器的进程，在打开一个记事本就启动一个记事本进程，如果打开两个记事本就启动两个记事本进程。

优点：

稳定性高，一个进程崩溃了，不会影响其他进程。
缺点：

创建进程开销巨大。
操作系统能同时运行的进程数目有限。
"""
#python中怎么创建进程?
#linux使用fork  windows使用multiprocess
#fork 模块在 Python 中用于创建子进程。它是 os 模块的一部分，主要用于 Unix 和 Unix-like 操作系统。fork 函数会创建一个子进程，子进程是父进程的一个副本。使用 fork 可以实现并发执行的效果。
from multiprocessing import Process
from time import sleep
import os   #getpid方法
def task1():
    while True:
        sleep(1)
        print('这是任务1,PID:',os.getpid(),'PPID:',os.getppid())  #ppid是副id

def task2():
    while True:
        sleep(1)     #休眠过程会把执行权让出去
        print('这是任务2,PID:',os.getpid(),'PPID:',os.getppid())
if __name__ == '__main__':   #从上往下运行 是主进程  task1和task2都是子进程
    #所以都是先运行完了主进程,再运行子进程  先打印了两个任务的名,再进到子进程里打印 这是任务1  这是任务2
    p = Process(target=task1,name='任务1')   #创建一个进程    name 给进程起名用的
    p.start()       #run只是让你做这个函数而已 想开辟进程,就要用start
    print(p.name)
    p1 = Process(target=task2,name='任务2')
    p1.start()
    print(p1.name)
    #由ppid相同,可见,任务1和任务2的线程都是由同一个副进程创建的
    """
run 方法：在调用线程的上下文中执行，不会创建新线程。
start 方法：在新线程的上下文中执行，会创建新线程。
由于 task1 和 task2 是在不同的进程中运行的，
操作系统会交替给它们分配 CPU 时间，从而实现并发执行。
task1 和 task2 会交替执行。具体来说，进程 p1 和 p2 会分别在各自的时间片内执行 sleep(1) 和 print('这是任务1') 
或 print('这是任务2')。由于 sleep(1) 会让进程休眠 1 秒，操作系统会在这段时间内将 CPU 分配给其他进程，从而实现任务的交替执行。

即使两个进程使用了同一个变量 p，它们仍然能够正常运行。这是因为在 Python 中，变量名只是对内存中对象的引用。每次你创建一个新的 Process 对象并赋值给 p 时，
p 只是更新为指向新的对象，而之前的 Process 对象仍然存在并且可以正常运行。
"""
