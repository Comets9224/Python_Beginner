#引用  是list  指有多少个指针指向他，用函数来查，本身也调用了一个
import sys
list=[1,2,3,4,5]
print(sys.getrefcount(list))
#初始引用：当你创建 list 时，它已经有一个引用指向它，即变量 list 本身。
#函数调用的额外引用：当你调用 sys.getrefcount(list) 时，list 作为参数传递给 sys.getrefcount 函数，这会临时增加 list 的引用计数。因此，
# 在函数内部，引用计数会比你预期的多 1。
#引用是引用的地址  赋地址 给人赋值
#传递方式，值是靠传递地址传递的
#alist 和blist都指向一个地址  a改了 ，b打印，里面也会改

#引用二
def test(n1):
    for i in range(n1):
        print('-------->',i)
    n1+=1
n=9
test(n)
print(n)
#打印出来n=9  因为n1+1=10  确实原来n1=n地址相同
#现在n1=10，和9就不是一个地址里，就影响不了了。
#理解为  n1 是函数内部的局部变量，n1怎么加都是在局部加，都影响不了n
#涉及到了变量池

#而定义列表，列表在函数内部改了，外部打印也会跟着改
#外部list=[1,2,3]  在函数内直接能修改列表，加值到列表中，打印出来列表也是变后的
#这里看着列表好像是全局的，也确实是全局的，主要原因还是因为列表是可变的类型，变量是不可变类型 ，包括元组、字符串也是不可变，
#字典列表集合这些都是可变的


#闭包就是函数的嵌套，函数内部嵌套函数   函数是一个变量，所以函数能定义在函数内

def outer():
    a=100
    def inner():
        b=200
        nonlocal a
        a-=100
        b+=a   #内部函数能查看外部函数的变量a  但是不能修改外部函数的变量  想修改 (gloab和nonlocal都是定义时候用)
        print("这是内部函数",b)
    # result=locals()   #locals 用在函数内部，查看有几个局部变量   查看函数内部  这里有a和inner两个变量
    #
    # print(result)
    print(a)
    inner()  # 也能在外部函数内 直接调用内部函数
outer()  #返回一个字典  inner也是一个变量 对应这个变量的值

#global全局 找的是最外层的a   当内层函数有a 再global  a想调全局函数，会有问题
#nonlocal则不会有问题

#找变量是先找内部，再找外部，再找全局  再找系统内置（比如sum函数）
